
/* This query roughly produces the menu structure. */

FOR group IN grouping
    SORT group.num
    LET children = (
        FOR division IN 1..1 OUTBOUND group `root_edges`
        SORT division.num
        LET parents = MERGE(FOR category IN 1..1 INBOUND division `root_edges`
        RETURN {[category.type] : category})
        RETURN UNSET_RECURSIVE(MERGE(division, parents),  '_rev', '_id', '_key', 'num', 'grouping')
    )

    RETURN UNSET({name: group.name, uid: group.uid, children: children}, '_rev', '_id', '_key', 'num')

/* UNSET is significantly slower than cherry-picking only the attributes you want*/

/* return all language objects */
FOR l IN language
    return l

/* return all language objects as a key: value mapping */
RETURN MERGE( /* Merges array of documents into one */
    FOR l IN language
        RETURN {[l.uid] : l} /* Set the key as the uid */
)

/* MERGE: Trying to merge 50000 documents failed with a timeout. Not sure why
because python can do the equivilant in the blink of an eye. Seems safe to assume
merge is not optimized for large result sets. */


/* Parallels API endpoint prototype */
LET pairs = (FOR entry, edge IN 1..1 ANY 'root/dn2' relationships
    /* We need to make sure the uid in question is on the "left hand side" which requires a conditional swap */
    /* we should also note if we've performed this swap because sometimes direction matter */
    RETURN (edge._from == 'root/dn2' ? {from: edge.from, to: edge.to, _from: edge._from, _to: edge._to} :
                                    {from: edge.to, to: edge.from, _from: edge._to, _to: edge._from, inverted: true}))


FOR result IN pairs
    COLLECT from = result.from INTO right = {
        to: result.to,
        _to: result._to
    }
    RETURN {
        left: from,
        right: (FOR e IN UNIQUE(right)
                    FOR sutta IN root
                        FILTER e._to == sutta._id
                        RETURN MERGE(e, {name: sutta.name})
                        /* todo: add a translated name */
                )
    }



/* This query creates edges between texts and their translations */
FOR sutta IN root
    FOR text IN html_text
        FILTER sutta.uid == text.uid
        INSERT {
            _from: sutta._id,
            _to: text._id,
            lang: text.lang
        } INTO text_edges
        

/* This query finds an ancestor of given type (i.e. language) it is quite fast*/
FOR entry IN 1..10 INBOUND @sutta_id root_edges
    FILTER entry.type == 'language'
    RETURN entry
    
